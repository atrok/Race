<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Car Racing Game</title>
    <style>
        canvas {
            display: block;
            margin: 0 auto;
            background: #333;
        }
    </style>
</head>

<body>
    <!--canvas id="gameCanvas" width="400" height="500"></canvas-->

    <div id="stage">
        <!--canvas id="background-layer" width="400" height="600"></canvas-->
        <canvas id="gameCanvas" width="400" height="550"></canvas>
        <canvas id="ui-layer" width="400" height="600"></canvas>
    </div>
    <div id="info">Press Space to start</div>

    <style>
        #stage {
            width: 400px;
            height: 600px;
            position: relative;
            border: 2px solid black;
        }

        canvas {
            position: absolute;
        }

        #background-layer {
            z-index: 1;
        }

        #gameCanvas {
            z-index: 3;
        }

        #ui-layer {
            z-index: 2;
            background: #000fff;
        }
    </style>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ui = document.getElementById("ui-layer");
        const ctx = canvas.getContext("2d");
        const ctx_ui = ui.getContext("2d");

        const carWidth = 50;
        const carHeight = 75;
        const carBuffer = 50
        const numberOfLanes = 4;
        const laneWidth = canvas.width / numberOfLanes;
        const finishline = -5000;
        const initYmin = canvas.height - carHeight - carBuffer;
        const initYmax = carBuffer;
        const shift_x = laneWidth;
        const shift_y = 20;
        const shift_speed = 0.5


        const maxOtherCars = 40;
        const otherCarSpeed = 1
        var lanes = null;
        var startTime, endTime;
        //const lane = 

        var playerCar = {
        };

        function createLane(id) {
            return {
                id: id,
                //speed: Math.floor(Math.random() * 3) / 2 + 2,
                speed: id + 1,
                cars: [],
                last_car_y: -0
            }
        }

        ;

        var gamegoing = false;
        var initialized = false;

        function init() {
            startTime = Date.now();

            let laneid = Math.floor(Math.random() * 3);
            playerCar = {
                id: laneid,
                x: laneid * laneWidth + (laneWidth - carWidth) / 2,
                y: initYmin,
                width: carWidth,
                height: carHeight,
                speed: 5,
                //color: "blue",
                img: "../Race/files/images/PNG/Cars/car_blue_small_1.png"

            };
            //


            //otherCars = [];
            createOtherCars();
            createFinishLine();

            gamegoing = true;
            initialized = true;

            update();

        }

        function drawCar(car) {
            //ctx.fillStyle = car.color;
            //ctx.fillRect(car.x, car.y, car.width, car.height);
            let img = new Image()
            img.src = car.img;
            ctx.drawImage(img, car.x, car.y)
        }

        function createFinishLine() {
            let finish = createLane('finish');
            finish.speed = playerCar.speed;

            finish.cars.push(
                {
                    x: 0,
                    y: finishline,
                    width: canvas.width,
                    height: 2,
                    //speed: otherCarSpeed + Math.random() * 2
                    speed: finish.speed,
                    color: "grey",
                    //img: "../Race/files/images/PNG/Cars/car_black_small_1.png"

                }
            )

            lanes.push(finish);

        }
        function createOtherCars() {

            lanes = Array(numberOfLanes);
            for (let i = 0; i < maxOtherCars; i++) {
                let lane = createLane(Math.floor(Math.random() * numberOfLanes));
                if (lanes[lane.id])
                    lane = lanes[lane.id];
                else
                    lanes[lane.id] = lane;

                let car = {
                    x: lane.id * laneWidth + (laneWidth - carWidth) / 2,
                    y: (lane.last_car_y - carBuffer) - carHeight - Math.random() * canvas.height,
                    width: carWidth,
                    height: carHeight,
                    //speed: otherCarSpeed + Math.random() * 2
                    speed: lane.speed + Math.random() * 3,
                    color: "red",
                    img: "../Race/files/images/PNG/Cars/car_black_small_1.png"
                };
                lane.cars.push(car);
                lane.last_car_y = car.y
                console.log(`Creating a car (attempt ${i + 1}\nlanes: ${JSON.stringify(lanes)}}`)
            }
        }

        // Function to check for collision between two rectangles
        function isColliding(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y;
        }

        function update() {

            if (gamegoing) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                drawCar(playerCar, 'blue');
                console.log(`Drawing objects for playerCar: speed:${playerCar.speed}, y:${playerCar.y}`)

                lanes.forEach(lane => {



                    lane.cars.forEach(car => {
                        switch (lane.id) {
                            case "finish":
                                car.y += playerCar.speed;

                                break;
                            default:
                                car.y += lane.speed;
                        }
                        console.log(`Drawing objects for lane: ${lane.id}, speed:${lane.speed}, y:${car.y}`)

                        /*
                        if (car.y > canvas.height) {
                            //car.y = -carHeight;
                            //car.speed = otherCarSpeed + Math.random() * 2;
                        }
*/
                        drawCar(car);

                        if (isColliding(car, playerCar)) {
                            gamegoing = false;
                            initialized = false;
                            switch (lane.id) {
                                case "finish":
                                    console.log("Finished!")
                                    //console.log(`Finished in: ${Date.now() - startTime}`)
                                    break;
                                default:
                                    console.log("Collision detected!");

                            }
                            console.log(`Finished in: ${Date.now() - startTime}`)
                            ctx.font = '20px Arial bold';
                            ctx.fillStyle = 'white'

                            // Draw text on the canvas
                            ctx.fillText(`Finished in: ${Date.now() - startTime}`, 100, 50);

                        }


                    });

                })

                requestAnimationFrame(update);

            }

            console.log(`gamegoing: ${gamegoing}`)
        }

        function movePlayerCar(event) {
            /*
            if (event.key === 'ArrowLeft' && playerCar.x > 0) {
                playerCar.x -= laneWidth;
            } else if (event.key === 'ArrowRight' && playerCar.x < canvas.width - laneWidth) {
                playerCar.x += laneWidth;
            }
*/
            switch (event.code) {
                case 'ArrowLeft':
                    if (playerCar.x > 0 && playerCar.x >= laneWidth) {
                        //playerCar.x -= laneWidth;
                        playerCar.x -= shift_x
                        playerCar.id--;
                    }

                    break;
                case 'ArrowRight':
                    if (playerCar.x < canvas.width - laneWidth) {
                        //playerCar.x += laneWidth;
                        playerCar.x += shift_x
                        playerCar.id++;
                    }

                    break;
                case "ArrowUp":
                    lanes.forEach(lane => {
                        //if (lane.id != playerCar.id)
                        lane.speed += shift_speed

                    })
                    playerCar.speed += shift_speed
                    if (playerCar.y > initYmax)
                        playerCar.y -= shift_y;
                    else
                        playerCar.y = initYmax;


                    break;
                case "ArrowDown":
                    lanes.forEach(lane => {
                        //   if (lane.id != playerCar.id)
                        lane.speed -= shift_speed

                    })
                    playerCar.speed -= shift_speed
                    if (playerCar.y < initYmin)
                        playerCar.y += shift_y;
                    else
                        playerCar.y = initYmin;

                    console.log(`playerCar.y:${playerCar.y}, initYmin:${initYmin}`)



                    break;

                case 'Space':
                    init();
                    break;
                case "Escape":
                    if (initialized) {
                        switch (gamegoing) {
                            case true:
                                gamegoing = false;
                                console.log('Game on pause')
                                break;
                            case false:
                                gamegoing = true;
                                update();
                                console.log("Game is resumed")
                        }
                    };
                default:
                    console.log(`event.key: ${event.code}`)

            }
        }

        document.addEventListener('keydown', movePlayerCar);


        // createOtherCars();
        // update();
    </script>
</body>

</html>